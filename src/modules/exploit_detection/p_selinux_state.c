/*
 * pi3's Linux kernel Runtime Guard
 *
 * Component:
 *  - selinux function
 *
 * Notes:
 *  - None
 *
 * Timeline:
 *  - Created: 18.I.2021
 *
 * Author:
 *  - Mariusz Zaborski (https://oshogbo.vexillium.org/)
 *
 */

#include "../../p_lkrg_main.h"

#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,17,0)

  #if LINUX_VERSION_CODE >= KERNEL_VERSION(5,9,0)
mm_segment_t p_uaccess_begin(void) {

   return force_uaccess_begin();
}
void p_uaccess_end(mm_segment_t oldfs) {

   force_uaccess_end(oldfs);
}
  #else
mm_segment_t p_uaccess_begin(void) {

   mm_segment_t saved;

   saved = get_fs();
   set_fs(USER_DS);

   return saved;
}
void p_uaccess_end(mm_segment_t oldfs) {

   set_fs(oldfs);
}
  #endif /* 5.9 */

static ssize_t (*p_sel_write_enforce)(void *, const char *buf, size_t count,
    loff_t *ppos);
static ssize_t (*p_sel_read_enforce)(void *, const char *buf, size_t count,
    loff_t *ppos);
static struct file *p_selinux_file_enforce;
const char *p_selinux_ubuf;

int p_selinux_state_init(void) {

   p_sel_write_enforce = (void *)P_SYM(p_kallsyms_lookup_name)("sel_write_enforce");
   p_sel_read_enforce = (void *)P_SYM(p_kallsyms_lookup_name)("sel_read_enforce");

   if (p_sel_write_enforce == NULL || p_sel_read_enforce == NULL)
      return P_LKRG_ERR;

   p_selinux_ubuf = kmalloc(20, GFP_USER);
   p_print_log(P_LKRG_ERR, "DEBUG %p", p_selinux_ubuf);

   p_selinux_file_enforce = filp_open("/sys/fs/selinux/enforce", O_RDWR, 0);
   if (p_selinux_file_enforce == NULL)
      return P_LKRG_ERR;

   p_selinux_state_update();
   return P_LKRG_SUCCESS;
}

void p_selinux_state_restore(void) {

   loff_t pos;
   char buf[8];

   snprintf(buf, sizeof(buf), "%d",
       p_ed_guard_globals.p_selinux.p_selinux_enforcing);

   pos = 0;
   if (!p_sel_write_enforce(p_selinux_file_enforce, buf, sizeof(buf), &pos))
      panic(P_LKRG_SIGNATURE "Unable to restore selinux_enable value.");
}


int p_selinux_state_enforcing(void) {

   char buf[16];
   loff_t pos;
   ssize_t ret;
   mm_segment_t saved;

   saved = p_uaccess_begin();
   pos = 0;
   p_selinux_buf = '\0';
   p_print_log(P_LKRG_ERR, "DEBUG %p", p_selinux_ubuf);
   ret = p_sel_read_enforce(p_selinux_file_enforce, p_selinux_ubuf, sizeof(buf), &pos);
   p_uaccess_end(saved);
   p_print_log(P_LKRG_ERR, "DEBUG %d %d", ret, saved);
   if (ret <= 0)
      return 0;
      //panic(P_LKRG_SIGNATURE "Unable to get current selinux_enable value.");
   buf[ret] = '\0';

   return strcmp(buf, "1") == 0;
}

void p_selinux_state_deinit(void) {

   filp_close(p_selinux_file_enforce, NULL);
}

 #else
int p_selinux_state_init(void) {
   P_SYM(p_selinux_enforcing) = (int *)P_SYM(p_kallsyms_lookup_name)("selinux_enforcing");

   if (P_SYM(p_selinux_enforcing))
      return P_LKRG_ERR;

   p_selinux_state_update();
   return P_LKRG_SUCCESS;
}

void p_selinux_restore(void) {
   P_SYM(p_selinux_enforcing) = p_ed_guard_globals.p_selinux.p_selinux_enforcing;
}

int p_selinux_state_enforcing(void) {
   return *P_SYM(p_selinux_enforcing);
}

void p_selinux_state_deinit(void) {
}
 #endif

void p_selinux_state_update(void) {

   p_ed_guard_globals.p_selinux.p_selinux_enforcing = p_selinux_state_enforcing();
}

int p_selinux_state_changed(void) {

   return p_selinux_state_enforcing() != p_ed_guard_globals.p_selinux.p_selinux_enforcing;
}

#endif
